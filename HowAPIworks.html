<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ItemController Breakdown</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
        }
        h1 {
            color: #333;
        }
        h2 {
            color: #0056b3;
        }
        code {
            display: block;
            background-color: #f4f4f4;
            padding: 10px;
            margin: 10px 0;
            border-left: 4px solid #ccc;
        }
        pre {
            background-color: #f9f9f9;
            padding: 15px;
            border: 1px solid #ccc;
        }
    </style>
</head>
<body>

<h1>ItemController Breakdown</h1>

<h2>Namespaces and Imports</h2>
<pre>
<code>
using Microsoft.AspNetCore.Mvc;
using API.Models;
using Microsoft.EntityFrameworkCore;
</code>
</pre>
<p><strong>Explanation:</strong></p>
<ul>
    <li><strong>using Microsoft.AspNetCore.Mvc</strong>: This imports the ASP.NET Core MVC framework to create controllers and define HTTP request-response pipelines.</li>
    <li><strong>using API.Models</strong>: Imports the Models namespace where the Item entity and InventoryDbContext are defined.</li>
    <li><strong>using Microsoft.EntityFrameworkCore</strong>: Imports Entity Framework Core, the ORM for interacting with the database.</li>
</ul>

<h2>Controller Definition</h2>
<pre>
<code>
namespace API.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    public class ItemsController : ControllerBase
    {
        private readonly InventoryDbContext _context;

        public ItemsController(InventoryDbContext context)
        {
            _context = context;
        }
</code>
</pre>
<p><strong>Explanation:</strong></p>
<ul>
    <li><strong>namespace API.Controllers</strong>: Declares the namespace for the ItemsController class.</li>
    <li><strong>[Route("api/[controller]")]</strong>: This attribute sets the base route for the controller as "api/items".</li>
    <li><strong>[ApiController]</strong>: Tells ASP.NET Core that this controller is responsible for handling API requests.</li>
    <li><strong>ControllerBase</strong>: Base class for Web API controllers, without view support (unlike Controller).</li>
    <li><strong>InventoryDbContext</strong>: Injects the database context via dependency injection to interact with the database.</li>
</ul>

<h2>GET All Items</h2>
<pre>
<code>
        // GET: api/items
        [HttpGet]
        public async Task<ActionResult<IEnumerable<Item>>> GetItems()
        {
            return await _context.Items.ToListAsync();
        }
</code>
</pre>
<p><strong>Explanation:</strong></p>
<ul>
    <li><strong>[HttpGet]</strong>: Maps this method to an HTTP GET request (e.g., GET api/items).</li>
    <li><strong>Task<ActionResult<IEnumerable&lt;Item&gt;>></strong>: Returns a task that results in a list of Item entities.</li>
    <li><strong>await _context.Items.ToListAsync()</strong>: Asynchronously retrieves all items from the database.</li>
</ul>

<h2>GET Item by ID</h2>
<pre>
<code>
        // GET: api/items/{id}
        [HttpGet("{id}")]
        public async Task<ActionResult<Item>> GetItem(string id)
        {
            var item = await _context.Items.FindAsync(id);

            if (item == null)
            {
                return NotFound();
            }

            return item;
        }
</code>
</pre>
<p><strong>Explanation:</strong></p>
<ul>
    <li><strong>[HttpGet("{id}")]</strong>: Maps to GET requests with an ID parameter in the URL (e.g., GET api/items/ITEM01).</li>
    <li><strong>FindAsync(id)</strong>: Retrieves the item from the database based on the provided ID.</li>
    <li><strong>return NotFound()</strong>: Returns a 404 status if the item is not found.</li>
</ul>

<h2>POST: Create a New Item</h2>
<pre>
<code>
        // POST: api/items
        [HttpPost]
        public async Task<ActionResult<Item>> PostItem(Item item)
        {
            _context.Items.Add(item);
            await _context.SaveChangesAsync();

            return CreatedAtAction(nameof(GetItem), new { id = item.ItemId }, item);
        }
</code>
</pre>
<p><strong>Explanation:</strong></p>
<ul>
    <li><strong>[HttpPost]</strong>: Maps this method to HTTP POST requests (e.g., POST api/items).</li>
    <li><strong>_context.Items.Add(item)</strong>: Adds the new item to the Items DbSet.</li>
    <li><strong>await _context.SaveChangesAsync()</strong>: Persists the new item to the database.</li>
    <li><strong>CreatedAtAction</strong>: Returns a 201 Created status and includes a Location header pointing to the newly created item.</li>
</ul>

<h2>PUT: Update an Existing Item</h2>
<pre>
<code>
        // PUT: api/items/{id}
        [HttpPut("{id}")]
        public async Task<IActionResult> PutItem(string id, Item item)
        {
            if (id != item.ItemId)
            {
                return BadRequest();
            }

            _context.Entry(item).State = EntityState.Modified;

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!ItemExists(id))
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }

            return NoContent();
        }
</code>
</pre>
<p><strong>Explanation:</strong></p>
<ul>
    <li><strong>[HttpPut("{id}")]</strong>: Maps to PUT requests with an ID parameter (e.g., PUT api/items/ITEM01).</li>
    <li><strong>_context.Entry(item).State = EntityState.Modified</strong>: Marks the item entity as modified, so Entity Framework updates the corresponding record in the database.</li>
    <li><strong>DbUpdateConcurrencyException</strong>: Catches concurrency issues if another transaction has updated the same item.</li>
    <li><strong>return NoContent()</strong>: Returns a 204 No Content status to indicate a successful update.</li>
</ul>

<h2>DELETE: Remove an Item</h2>
<pre>
<code>
        // DELETE: api/items/{id}
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteItem(string id)
        {
            var item = await _context.Items.FindAsync(id);
            if (item == null)
            {
                return NotFound();
            }

            _context.Items.Remove(item);
            await _context.SaveChangesAsync();

            return NoContent();
        }
</code>
</pre>
<p><strong>Explanation:</strong></p>
<ul>
    <li><strong>[HttpDelete("{id}")]</strong>: Maps to DELETE requests with an ID parameter (e.g., DELETE api/items/ITEM01).</li>
    <li><strong>_context.Items.FindAsync(id)</strong>: Finds the item by its ID in the database.</li>
    <li><strong>_context.Items.Remove(item)</strong>: Removes the item from the database.</li>
    <li><strong>await _context.SaveChangesAsync()</strong>: Saves the changes and deletes the item from the database.</li>
</ul>

<h2>Conclusion</h2>
<p>This controller handles the CRUD operations (Create, Read, Update, Delete) for the Item entity, interacting with the database using Entity Framework Core.</p>
<p>The flow of each API request involves mapping routes to specific methods, retrieving or modifying the database records via <strong>InventoryDbContext</strong>, and returning appropriate HTTP responses to the client.</p>

</body>
</html>
